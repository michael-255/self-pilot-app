-- |---------------------------------------|
-- | Policy Type | USING      | WITH CHECK |
-- |-------------|------------|------------|
-- | SELECT      | Yes        | No         |
-- | INSERT      | No         | Yes        |
-- | UPDATE      | Yes        | Yes        |
-- | DELETE      | Yes        | No         |
-- |---------------------------------------|

--
-- Schema
--
CREATE SCHEMA IF NOT EXISTS app_journal AUTHORIZATION postgres;

GRANT USAGE ON SCHEMA app_journal TO authenticated, service_role;

--
-- Tables
--
CREATE TABLE app_journal.writing_categories (
  id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  slug TEXT NOT NULL UNIQUE,
  name TEXT NOT NULL
);

ALTER TABLE app_journal.writing_categories ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Authenticated users can read categories" ON app_journal.writing_categories
FOR SELECT TO authenticated
USING (true);

CREATE TABLE app_journal.writing_entries (
  id UUID PRIMARY KEY DEFAULT extensions.gen_random_uuid(),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  owner_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  category_id INTEGER NOT NULL REFERENCES app_journal.writing_categories(id),
  subject TEXT NOT NULL,
  body TEXT NOT NULL,
  search_vector tsvector GENERATED ALWAYS AS (
    setweight(to_tsvector('english', COALESCE(subject, '')), 'A') ||
    setweight(to_tsvector('english', COALESCE(body, '')), 'B')
  ) STORED
);

CREATE INDEX IF NOT EXISTS writing_entries_search_vector_idx
  ON app_journal.writing_entries USING GIN (search_vector);

ALTER TABLE app_journal.writing_entries ENABLE ROW LEVEL SECURITY;
GRANT SELECT, INSERT, UPDATE, DELETE ON app_journal.writing_entries TO authenticated, service_role;

CREATE POLICY "Authenticated users can read their own entries" ON app_journal.writing_entries
FOR SELECT TO authenticated
USING (owner_id = (SELECT auth.uid()));

CREATE POLICY "Authenticated users can insert their own entries" ON app_journal.writing_entries
FOR INSERT TO authenticated
WITH CHECK (owner_id = (SELECT auth.uid()));

CREATE POLICY "Authenticated users can update their own entries" ON app_journal.writing_entries
FOR UPDATE TO authenticated
USING (owner_id = (SELECT auth.uid()))
WITH CHECK (owner_id = (SELECT auth.uid()));

CREATE POLICY "Authenticated users can delete their own entries" ON app_journal.writing_entries
FOR DELETE TO authenticated
USING (owner_id = (SELECT auth.uid()));

--
-- Functions
--
CREATE OR REPLACE FUNCTION app_journal.set_updated_at()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;

REVOKE EXECUTE ON FUNCTION app_journal.set_updated_at() FROM anon, authenticated;

--
-- Triggers
--
CREATE TRIGGER writing_entries_updated_at_trigger
BEFORE UPDATE ON app_journal.writing_entries
FOR EACH ROW
EXECUTE FUNCTION app_journal.set_updated_at();

--
-- Seed Categories
--
INSERT INTO app_journal.writing_categories (slug, name) VALUES
  ('journaling', 'Journaling'),
  ('weekly-review', 'Weekly Review'),
  ('yearly-review', 'Yearly Review'),
  ('goals-planning', 'Goals & Planning'),
  ('brainstorming', 'Brainstorming'),
  ('creative', 'Creative'),
  ('other', 'Other')
ON CONFLICT (slug) DO NOTHING;

--
-- Schema
--
CREATE SCHEMA IF NOT EXISTS api_journal AUTHORIZATION postgres;


GRANT USAGE ON SCHEMA api_journal TO authenticated, service_role;

--
-- Views
--
CREATE OR REPLACE VIEW api_journal.writing_categories_view
WITH (security_invoker=on) AS
  SELECT id, slug, name
  FROM app_journal.writing_categories;

REVOKE SELECT ON api_journal.writing_categories_view FROM anon;
GRANT SELECT ON api_journal.writing_categories_view TO authenticated, service_role;

--
-- Functions
--
CREATE OR REPLACE FUNCTION api_journal.search_writing_entries(
  in_category_id INTEGER DEFAULT NULL,
  in_start_date TIMESTAMPTZ DEFAULT NULL,
  in_end_date TIMESTAMPTZ DEFAULT NULL,
  in_query TEXT DEFAULT NULL,
  in_offset INTEGER DEFAULT 0
)
RETURNS TABLE (
  id UUID,
  created_at TIMESTAMPTZ,
  updated_at TIMESTAMPTZ,
  owner_id UUID,
  category_id INTEGER,
  subject TEXT,
  body TEXT,
  rank DOUBLE PRECISION
)
LANGUAGE sql
SECURITY INVOKER
SET search_path = ''
AS $$
  SELECT
    e.id,
    e.created_at,
    e.updated_at,
    e.owner_id,
    e.category_id,
    e.subject,
    e.body,
    CASE
      WHEN in_query IS NOT NULL AND in_query <> ''
      THEN ts_rank(e.search_vector, plainto_tsquery('english', in_query))
      ELSE NULL
    END AS rank
  FROM app_journal.writing_entries e
  WHERE e.owner_id = auth.uid()
    AND (in_category_id IS NULL OR e.category_id = in_category_id)
    AND (in_start_date IS NULL OR e.created_at >= in_start_date)
    AND (in_end_date IS NULL OR e.created_at <= in_end_date)
    AND (
      in_query IS NULL OR in_query = '' OR
      e.search_vector @@ plainto_tsquery('english', in_query)
    )
  ORDER BY rank DESC NULLS LAST, e.created_at DESC
  LIMIT 50 OFFSET in_offset
$$;

-- TODO: get_writing_entry

-- TODO: create_writing_entry

-- TODO: update_writing_entry

-- TODO: delete_writing_entry
